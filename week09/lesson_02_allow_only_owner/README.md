# How to: Make sure only the owner of the data can read it

## User Profile Structure

Consider you have a node named `userprofiles` in your real-time database. Children of this node have the unique id (uid) of the user as its key, and each key stores an object representing the user's profile. It could look like this:

```javascript
"userprofiles": {

    "6842c1pSL8OP34Bf812JRq6e7Yh1": {
        "firstname": "Max",
        "lastname": "Mustermann",
        "dateofbirth": "01.01.1990"
    },
    
    "DMpMS4IY5wauWoV4gOq6vC8lp4t2": {
        "firstname": "Erika",
        "lastname": "Mustermann",
        "dateofbirth": "24.12.1987"
    }
}
```

Recall that the `uid` is generated by Firebase when a user is created, and that it is unique for a user. You can access the `uid` from your Javascript code with `user.uid`.

## Targeting users with a database rule

We have learned in the previous lesson that we can secure read and write access using Firebase's database rules. In the previous lessson, we have restricted read and write operations to signed in users, but we allowed any signed in user to read and write. How can we allow only specific users - or one specific user, namely the profile owner, to read and write it? 

Here is why is is extremely useful to store user profiles with the `uid` as its key. Using Firebase's database rules, we have access to the currently signed in user's standard profile, which includes the `uid` field. In addition, we can use placeholders in our rules which are filled with a corresponding value at validation time. With that, restricting the access to a specific user profile is as simple as this:

```javascript
{
  "rules": {
    "userprofiles": {
      "$uid": {
        ".read": "$uid === auth.uid"  
        ".write": "$uid === auth.uid"
      }
    }
  }
}
```

So what does the above set of rules imply? For the node `userprofiles`, we define a rule for all children named `$uid`. As you may have guessed, `$uid` is a placeholder for a specific value that the app wants to read or write to. More precisely, it is a placeholder for the `uid` of a specific user at runtime. We won't know who the user is until the rule is exectuted. That is why a placeholder works like magic here. We only define *one* abstract rule to cover all possible users, and we don't have to create rules for each individual user.

And what about the rule's condition `$uid === auth.uid`? Well, this says that we allow read or write only if the placeholder value (which is replaced with a specific `uid` when we validate this rule) equals the `uid` of the currently signed in user. We can check the currently signed in user with the `auth` object, which Firebase gives us access to in validating database rules.

Anytime a user X tries to read the user Y's profile, the database rule will deny this access as defined by the rule. Only if user X tries to read his own profile with the key `X.uid`, the rule will grant the access.

The above in a simple but useful example for a database rule. With Firebase database rules, you can do much more than this. Since Firebase offers access not only to the `auth` variable, but also to other objects such as the entire database, or the new data that should be written by a write request, you can express almost any rule. To learn more, read the official documentation:

- [Understanding Firebase Real Time Database Rules](https://firebase.google.com/docs/database/security/)
- [Get started with Database Rules](https://firebase.google.com/docs/database/security/quickstart)
- [Secure Your Data](https://firebase.google.com/docs/database/security/securing-data)

## Uploading JSON data to your database

The animation below demonstrates how you can use the example file and upload it to your database.

![Import JSON to Firebase database](/media/Firebase Database Import JSON-min.gif)